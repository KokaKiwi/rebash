{
  "name": "Rebash",
  "tagline": "ReBash - bash scripting library/framework",
  "body": "# ReBash - bash/shell library/framework\r\n## Features\r\n- modular import system\r\n- advanced logging (colors, control stdout/stderr, log levels, ...)\r\n- error handling (exceptions, try-catch)\r\n- doc testing inspired by python\r\n- documentation generation\r\n- argument parser\r\n\r\n## Usage\r\n```\r\n#!/usr/bin/env bash\r\nsource path/to/core.sh\r\ncore.import <modulename>\r\ncore.import <another modulename>\r\n# use modules ...\r\n```\r\n\r\n## Module Overview\r\n- [core](#module-core)\r\n- [logging](#module-logging)\r\n- [ui](#module-ui)\r\n- [exceptions](#module-exceptions)\r\n- [doc_test](#module-doc_test)\r\n- [documentation](#module-documentation)\r\n- [array](#module-array)\r\n- [arguments](#module-arguments)\r\n\r\n# Generated documentation\r\n## Module arguments\r\n### Function arguments_get_flag\r\n\r\n\r\n```\r\narguments.get_flag flag [flag_aliases...] variable_name\r\n```\r\n\r\nSets `variable_name` to true if flag (or on of its aliases) is contained in\r\nthe argument array (see `arguments.set`)\r\n\r\n- Example\r\n```\r\narguments.get_flag verbose --verbose -v verbose_is_set\r\n```\r\n- Tests\r\n```bash\r\n>>> arguments.set other_param1 --foo other_param2\r\n>>> local foo bar\r\n>>> arguments.get_flag --foo -f foo\r\n>>> echo $foo\r\n>>> arguments.get_flag --bar bar\r\n>>> echo $bar\r\n>>> echo \"${arguments_new_arguments[@]}\"\r\ntrue\r\nfalse\r\nother_param1 other_param2\r\n```\r\n\r\n```bash\r\n>>> arguments.set -f\r\n>>> local foo\r\n>>> arguments.get_flag --foo -f foo\r\n>>> echo $foo\r\ntrue\r\n```\r\n### Function arguments_get_keyword\r\n\r\n\r\n```\r\narguments.get_keyword keyword variable_name\r\n```\r\n\r\nSets `variable_name` to the \"value\" of `keyword` the argument array (see\r\n`arguments.set`) contains \"keyword=value\".\r\n\r\n- Example\r\n```\r\narguments.get_keyword log loglevel\r\n```\r\n- Tests\r\n```bash\r\n>>> local foo\r\n>>> arguments.set other_param1 foo=bar baz=baz other_param2\r\n>>> arguments.get_keyword foo foo\r\n>>> echo $foo\r\n>>> echo \"${arguments_new_arguments[@]}\"\r\nbar\r\nother_param1 baz=baz other_param2\r\n```\r\n### Function arguments_get_parameter\r\n\r\n\r\n```\r\narguments.get_parameter parameter [parameter_aliases...] variable_name\r\n```\r\n\r\nSets `variable_name` to the field following `parameter` (or one of the\r\n`parameter_aliases`) from the argument array (see `arguments.set`).\r\n\r\n- Example\r\n```\r\narguments.get_parameter --log-level -l loglevel\r\n```\r\n\r\n- Tests\r\n```bash\r\n>>> local foo\r\n>>> arguments.set other_param1 --foo bar other_param2\r\n>>> arguments.get_parameter --foo -f foo\r\n>>> echo $foo\r\n>>> echo \"${arguments_new_arguments[@]}\"\r\nbar\r\nother_param1 other_param2\r\n```\r\n### Function arguments_set\r\n\r\n\r\n```\r\narguments.set argument1 argument2 ...\r\n```\r\n\r\nSet the array the arguments-module is working on. After getting the desired\r\narguments, the new argument array can be accessed via\r\n`arguments_new_arguments`. This new array contains all remaining arguments.\r\n## Module array\r\n### Function array_filter\r\n\r\n\r\nFilters values from given array by given regular expression.\r\n\r\n```bash\r\n>>> local a=(one two three wolf)\r\n>>> local b=( $(array.filter \".*wo.*\" \"${a[@]}\") )\r\n>>> echo ${b[*]}\r\ntwo wolf\r\n```\r\n### Function array_get_index\r\n\r\n\r\nGet index of value in an array\r\n\r\n```bash\r\n>>> local a=(one two three)\r\n>>> array_get_index one \"${a[@]}\"\r\n0\r\n```\r\n\r\n```bash\r\n>>> local a=(one two three)\r\n>>> array_get_index two \"${a[@]}\"\r\n1\r\n```\r\n\r\n```bash\r\n>>> array_get_index bar foo bar baz\r\n1\r\n```\r\n### Function array_slice\r\n\r\n\r\nReturns a slice of an array (similar to Python).\r\n\r\nFrom the Python documentation:\r\nOne way to remember how slices work is to think of the indices as pointing\r\nbetween elements, with the left edge of the first character numbered 0.\r\nThen the right edge of the last element of an array of length n has\r\nindex n, for example:\r\n```\r\n+---+---+---+---+---+---+\r\n| 0 | 1 | 2 | 3 | 4 | 5 |\r\n+---+---+---+---+---+---+\r\n0   1   2   3   4   5   6\r\n-6  -5  -4  -3  -2  -1\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> echo $(array.slice 1:-2 \"${a[@]}\")\r\n1 2 3\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> echo $(array.slice 0:1 \"${a[@]}\")\r\n0\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> [ -z \"$(array.slice 1:1 \"${a[@]}\")\" ] && echo empty\r\nempty\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> [ -z \"$(array.slice 2:1 \"${a[@]}\")\" ] && echo empty\r\nempty\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> [ -z \"$(array.slice -2:-3 \"${a[@]}\")\" ] && echo empty\r\nempty\r\n```\r\n\r\n```bash\r\n>>> [ -z \"$(array.slice -2:-2 \"${a[@]}\")\" ] && echo empty\r\nempty\r\n```\r\n\r\nSlice indices have useful defaults; an omitted first index defaults to\r\nzero, an omitted second index defaults to the size of the string being\r\nsliced.\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> # from the beginning to position 2 (excluded)\r\n>>> echo $(array.slice 0:2 \"${a[@]}\")\r\n>>> echo $(array.slice :2 \"${a[@]}\")\r\n0 1\r\n0 1\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> # from position 3 (included) to the end\r\n>>> echo $(array.slice 3:\"${#a[@]}\" \"${a[@]}\")\r\n>>> echo $(array.slice 3: \"${a[@]}\")\r\n3 4 5\r\n3 4 5\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> # from the second-last (included) to the end\r\n>>> echo $(array.slice -2:\"${#a[@]}\" \"${a[@]}\")\r\n>>> echo $(array.slice -2: \"${a[@]}\")\r\n4 5\r\n4 5\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> echo $(array.slice -4:-2 \"${a[@]}\")\r\n2 3\r\n```\r\n\r\nIf no range is given, it works like normal array indices.\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> echo $(array.slice -1 \"${a[@]}\")\r\n5\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> echo $(array.slice -2 \"${a[@]}\")\r\n4\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> echo $(array.slice 0 \"${a[@]}\")\r\n0\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> echo $(array.slice 1 \"${a[@]}\")\r\n1\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> array.slice 6 \"${a[@]}\"; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> local a=(0 1 2 3 4 5)\r\n>>> array.slice -7 \"${a[@]}\"; echo $?\r\n1\r\n```\r\n## Module change_root\r\n### Function change_root\r\n\r\n\r\nThis function performs a linux change root if needed and provides all\r\nkernel api filesystems in target root by using a change root interface\r\nwith minimal needed rights.\r\n\r\nExamples:\r\n\r\n`change_root /new_root /usr/bin/env bash some arguments`\r\n### Function change_root_with_fake_fallback\r\n\r\n\r\nPerform the available change root program wich needs at least rights.\r\n\r\nExamples:\r\n\r\n`change_root_with_fake_fallback /new_root /usr/bin/env bash some arguments`\r\n### Function change_root_with_kernel_api\r\n\r\n\r\nPerforms a change root by mounting needed host locations in change root\r\nenvironment.\r\n\r\nExamples:\r\n\r\n`change_root_with_kernel_api /new_root /usr/bin/env bash some arguments`\r\n## Module core\r\n### Function core_get_all_declared_names\r\n\r\n\r\nReturn all declared variables and function in the current\r\nscope.\r\n\r\nE.g.\r\n`declarations=\"$(core.get_all_declared_names)\"`\r\n### Function core_import\r\n\r\n\r\n```bash\r\n>>> (core.import ./test/mockup_module-b.sh)\r\nimported module c\r\nwarn: module \"mockup_module_c\" defines unprefixed name: \"foo123\"\r\nimported module b\r\n```\r\n\r\nModules should be imported only once.\r\n```bash\r\n>>> (core.import ./test/mockup_module_a.sh && \\\r\n>>>     core.import ./test/../test/mockup_module_a.sh)\r\nimported module a\r\n```\r\n\r\n```bash\r\n>>> (\r\n>>> core.import exceptions\r\n>>> exceptions.activate\r\n>>> core.import utils\r\n>>> )\r\n\r\n```\r\n### Function core_is_defined\r\n\r\n\r\nTests if variable is defined (can alo be empty)\r\n\r\n```bash\r\n>>> local foo=\"bar\"\r\n>>> core_is_defined foo; echo $?\r\n>>> [[ -v foo ]]; echo $?\r\n0\r\n0\r\n```\r\n\r\n```bash\r\n>>> local defined_but_empty=\"\"\r\n>>> core_is_defined defined_but_empty; echo $?\r\n0\r\n```\r\n\r\n```bash\r\n>>> core_is_defined undefined_variable; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> set -u\r\n>>> core_is_defined undefined_variable; echo $?\r\n1\r\n```\r\n\r\nSame Tests for bash < 4.2\r\n```bash\r\n>>> core__bash_version_test=true\r\n>>> local foo=\"bar\"\r\n>>> core_is_defined foo; echo $?\r\n0\r\n```\r\n\r\n```bash\r\n>>> core__bash_version_test=true\r\n>>> local defined_but_empty=\"\"\r\n>>> core_is_defined defined_but_empty; echo $?\r\n0\r\n```\r\n\r\n```bash\r\n>>> core__bash_version_test=true\r\n>>> core_is_defined undefined_variable; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> core__bash_version_test=true\r\n>>> set -u\r\n>>> core_is_defined undefined_variable; echo $?\r\n1\r\n```\r\n### Function core_is_empty\r\n\r\n\r\nTests if variable is empty (undefined variables are not empty)\r\n\r\n```bash\r\n>>> local foo=\"bar\"\r\n>>> core_is_empty foo; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> local defined_and_empty=\"\"\r\n>>> core_is_empty defined_and_empty; echo $?\r\n0\r\n```\r\n\r\n```bash\r\n>>> core_is_empty undefined_variable; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> set -u\r\n>>> core_is_empty undefined_variable; echo $?\r\n1\r\n```\r\n### Function core_is_main\r\n\r\n\r\nReturns true if current script is being executed.\r\n\r\n```bash\r\n>>> core.is_main && echo yes\r\nyes\r\n```\r\n### Function core_rel_path\r\n\r\n\r\nComputes relative path from $1 to $2.\r\n\r\n```bash\r\n>>> core_rel_path \"/A/B/C\" \"/A\"\r\n../..\r\n```\r\n\r\n```bash\r\n>>> core_rel_path \"/A/B/C\" \"/A/B\"\r\n..\r\n```\r\n\r\n```bash\r\n>>> core_rel_path \"/A/B/C\" \"/A/B/C\"\r\n.\r\n```\r\n\r\n```bash\r\n>>> core_rel_path \"/A/B/C\" \"/A/B/C/D\"\r\nD\r\n```\r\n\r\n```bash\r\n>>> core_rel_path \"/A/B/C\" \"/A/B/C/D/E\"\r\nD/E\r\n```\r\n\r\n```bash\r\n>>> core_rel_path \"/A/B/C\" \"/A/B/D\"\r\n../D\r\n```\r\n\r\n```bash\r\n>>> core_rel_path \"/A/B/C\" \"/A/B/D/E\"\r\n../D/E\r\n```\r\n\r\n```bash\r\n>>> core_rel_path \"/A/B/C\" \"/A/D\"\r\n../../D\r\n```\r\n\r\n```bash\r\n>>> core_rel_path \"/A/B/C\" \"/A/D/E\"\r\n../../D/E\r\n```\r\n\r\n```bash\r\n>>> core_rel_path \"/A/B/C\" \"/D/E/F\"\r\n../../../D/E/F\r\n```\r\n### Function core_unique\r\n\r\n\r\n```bash\r\n>>> local foo=\"a\r\nb\r\na\r\nb\r\nc\r\nb\r\nc\"\r\n>>> echo -e \"$foo\" | core.unique\r\na\r\nb\r\nc\r\n```\r\n## Module dictionary\r\n### Function dictionary_get\r\n\r\n\r\nUsage:\r\nvariable=$(dictionary.get dictionary_name key)\r\n\r\nExamples:\r\n\r\n```bash\r\n>>> dictionary_get unset_map unset_value\r\n>>> dictionary_get unset_map unset_value; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_get unset_map unset_value; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> dictionary_set map foo 2\r\n>>> dictionary_set map bar 1\r\n>>> dictionary_get map foo\r\n>>> dictionary_get map bar\r\n2\r\n1\r\n```\r\n\r\n```bash\r\n>>> dictionary_set map foo \"a b c\"\r\n>>> dictionary_get map foo\r\na b c\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_set map foo 2\r\n>>> dictionary_get map foo\r\n2\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_set map foo \"a b c\"\r\n>>> dictionary_get map foo\r\na b c\r\n```\r\n### Function dictionary_get_keys\r\n\r\n\r\n```bash\r\n>>> dictionary_set map foo \"a b c\" bar 5\r\n>>> dictionary_get_keys map\r\nbar\r\nfoo\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_set map foo \"a b c\" bar 5\r\n>>> dictionary_get_keys map | sort -u\r\nbar\r\nfoo\r\n```\r\n### Function dictionary_set\r\n\r\n\r\nUsage:\r\ndictionary.set dictionary_name key value\r\n\r\nTests:\r\n\r\n```bash\r\n>>> dictionary_set map foo 2\r\n>>> echo ${dictionary__store_map[foo]}\r\n2\r\n```\r\n\r\n```bash\r\n>>> dictionary_set map foo \"a b c\" bar 5\r\n>>> echo ${dictionary__store_map[foo]}\r\n>>> echo ${dictionary__store_map[bar]}\r\na b c\r\n5\r\n```\r\n\r\n```bash\r\n>>> dictionary_set map foo \"a b c\" bar; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_set map foo 2\r\n>>> echo $dictionary__store_map_foo\r\n2\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_set map foo \"a b c\"\r\n>>> echo $dictionary__store_map_foo\r\na b c\r\n```\r\n## Module doc_test\r\n\r\n\r\nThe doc_test module implements function and module level testing via \"doc\r\nstrings\".\r\n\r\nTests can be run by invoking `doc_test.sh file1 folder1 file2 ...`.\r\n\r\n#### Example output\r\n```bash\r\n[info:doc_test.sh:433] arguments_get_flag:[PASS]\r\n[info:doc_test.sh:433] arguments_get_keyword:[PASS]\r\n[info:doc_test.sh:433] arguments_get_parameter:[PASS]\r\n[info:doc_test.sh:433] arguments_set:[PASS]\r\n```\r\n\r\nA doc string can be defined for a function by defining a variable named\r\n`__doc__` at the function scope.\r\nOn the module level, the variable name should be `<module_name>__doc__`\r\n(e.g. `arguments__doc__` for the example above).\r\nNote: The doc string needs to be defined with single quotes.\r\n\r\nCode contained in a module level variable named\r\n`<module_name>__doc_test_setup__` will be run once before all the Tests of\r\na module are run. This is usefull for defining mockup functions/data\r\nthat can be used throughout all tests.\r\n\r\n#### Tests\r\n\r\nTests are delimited by blank lines:\r\n```bash\r\n>>> echo bar\r\nbar\r\n```\r\n\r\n```bash\r\n>>> echo $(( 1 + 2 ))\r\n3\r\n```\r\n\r\nBut can also occur right after another:\r\n```bash\r\n>>> echo foo\r\nfoo\r\n```\r\n\r\n```bash\r\n>>> echo bar\r\nbar\r\n```\r\n\r\nSingle quotes can be escaped like so:\r\n```bash\r\n>>> echo '$foos'\r\n$foos\r\n```\r\n\r\nOr so\r\n```bash\r\n>>> echo '$foos'\r\n$foos\r\n```\r\n\r\nSome text in between.\r\n\r\nMultiline output\r\n```bash\r\n>>> local i\r\n>>> for i in 1 2; do\r\n>>>     echo $i;\r\n>>> done\r\n1\r\n2\r\n```\r\n\r\nEllipsis support\r\n```bash\r\n>>> local i\r\n>>> for i in 1 2 3 4 5; do\r\n>>>     echo $i;\r\n>>> done\r\n+doc_test_ellipsis\r\n1\r\n2\r\n...\r\n```\r\n\r\nEllipsis are non greedy\r\n```bash\r\n>>> local i\r\n>>> for i in 1 2 3 4 5; do\r\n>>>     echo $i;\r\n>>> done\r\n+doc_test_ellipsis\r\n1\r\n...\r\n4\r\n5\r\n```\r\n\r\nEach testcase has its own scope:\r\n```bash\r\n>>> local testing=\"foo\"; echo $testing\r\nfoo\r\n```\r\n\r\n```bash\r\n>>> [ -z \"$testing\" ] && echo empty\r\nempty\r\n```\r\n\r\nSyntax error in testcode:\r\n```bash\r\n>>> f() {a}\r\n+doc_test_contains\r\n+doc_test_ellipsis\r\nsyntax error near unexpected token `{a}\r\n...\r\n```\r\n### Function doc_test_compare_result\r\n\r\n\r\n```bash\r\n>>> buffer=\"line 1\r\n>>> line 2\"\r\n>>> got=\"line 1\r\n>>> line 2\"\r\n>>> doc_test_compare_result \"$buffer\" \"$got\"; echo $?\r\n0\r\n```\r\n\r\n```bash\r\n>>> buffer=\"line 1\r\n>>> foo\"\r\n>>> got=\"line 1\r\n>>> line 2\"\r\n>>> doc_test_compare_result \"$buffer\" \"$got\"; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> buffer=\"+doc_test_contains\r\n>>> line\r\n>>> line\"\r\n>>> got=\"line 1\r\n>>> line 2\"\r\n>>> doc_test_compare_result \"$buffer\" \"$got\"; echo $?\r\n0\r\n```\r\n\r\n```bash\r\n>>> buffer=\"+doc_test_contains\r\n>>> line\r\n>>> foo\"\r\n>>> got=\"line 1\r\n>>> line 2\"\r\n>>> doc_test_compare_result \"$buffer\" \"$got\"; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> buffer=\"+doc_test_ellipsis\r\n>>> line\r\n>>> ...\r\n>>> \"\r\n>>> got=\"line\r\n>>> line 2\r\n>>> \"\r\n>>> doc_test_compare_result \"$buffer\" \"$got\"; echo $?\r\n0\r\n```\r\n\r\n```bash\r\n>>> buffer=\"+doc_test_ellipsis\r\n>>> line\r\n>>> ...\r\n>>> line 2\r\n>>> \"\r\n>>> got=\"line\r\n>>> ignore\r\n>>> ignore\r\n>>> line 2\r\n>>> \"\r\n>>> doc_test_compare_result \"$buffer\" \"$got\"; echo $?\r\n0\r\n```\r\n\r\n```bash\r\n>>> buffer=\"+doc_test_ellipsis\r\n>>> line\r\n>>> ...\r\n>>> line 2\r\n>>> \"\r\n>>> got=\"line\r\n>>> ignore\r\n>>> ignore\r\n>>> line 2\r\n>>> line 3\r\n>>> \"\r\n>>> doc_test_compare_result \"$buffer\" \"$got\"; echo $?\r\n1\r\n```\r\n## Module documentation\r\n## Module exceptions\r\n\r\n\r\nNOTE: The try block is executed in a subshell, so no outer variables can be\r\nassigned.\r\n\r\n```bash\r\n>>> exceptions.activate\r\n>>> false\r\n+doc_test_ellipsis\r\nTraceback (most recent call first):\r\n...\r\n```\r\n\r\n```bash\r\n>>> exceptions_activate\r\n>>> exceptions.try {\r\n>>>     false\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\ncaught\r\n```\r\n\r\nExceptions in a subshell:\r\n```bash\r\n>>> exceptions_activate\r\n>>> ( false )\r\n+doc_test_ellipsis\r\nTraceback (most recent call first):\r\n...\r\nTraceback (most recent call first):\r\n...\r\n```\r\n\r\n```bash\r\n>>> exceptions_activate\r\n>>> exceptions.try {\r\n>>>     (false; echo \"this should not be printed\")\r\n>>>     echo \"this should not be printed\"\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\n+doc_test_ellipsis\r\ncaught\r\n```\r\n\r\nNested exceptions:\r\n```bash\r\n>>> exceptions_foo() {\r\n>>>     true\r\n>>>     exceptions.try {\r\n>>>         false\r\n>>>     }; exceptions.catch {\r\n>>>         echo caught inside foo\r\n>>>     }\r\n>>>     false # this is cought at top level\r\n>>>     echo this should never be printed\r\n>>> }\r\n>>>\r\n>>> exceptions.try {\r\n>>>     exceptions_foo\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\n>>>\r\ncaught inside foo\r\ncaught\r\n```\r\n\r\nExceptions are implicitely active inside try blocks:\r\n```bash\r\n>>> foo() {\r\n>>>     echo $1\r\n>>>     true\r\n>>>     exceptions.try {\r\n>>>         false\r\n>>>     }; exceptions.catch {\r\n>>>         echo caught inside foo\r\n>>>     }\r\n>>>     false # this is not caught\r\n>>>     echo this should never be printed\r\n>>> }\r\n>>>\r\n>>> foo \"EXCEPTIONS NOT ACTIVE:\"\r\n>>> exceptions_activate\r\n>>> foo \"EXCEPTIONS ACTIVE:\"\r\n+doc_test_ellipsis\r\nEXCEPTIONS NOT ACTIVE:\r\ncaught inside foo\r\nthis should never be printed\r\nEXCEPTIONS ACTIVE:\r\ncaught inside foo\r\nTraceback (most recent call first):\r\n...\r\n```\r\n\r\nExceptions inside conditionals:\r\n```bash\r\n>>> exceptions_activate\r\n>>> false && echo \"should not be printed\"\r\n>>> (false) && echo \"should not be printed\"\r\n>>> exceptions.try {\r\n>>>     (\r\n>>>     false\r\n>>>     echo \"should not be printed\"\r\n>>>     )\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\ncaught\r\n```\r\n\r\nReraise exception\r\n```bash\r\n>>> exceptions.try {\r\n>>>     false\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>>     echo \"$exceptions_last_traceback\"\r\n>>> }\r\n+doc_test_ellipsis\r\ncaught\r\nTraceback (most recent call first):\r\n...\r\n```\r\n\r\n```bash\r\n>>> exceptions.try {\r\n>>>     ! true\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\n\r\n```\r\n\r\n```bash\r\n>>> exceptions.try\r\n>>>     false\r\n>>> exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\ncaught\r\n```\r\n\r\n```bash\r\n>>> exceptions.try\r\n>>>     false\r\n>>> exceptions.catch\r\n>>>     echo caught\r\ncaught\r\n```\r\n\r\n```bash\r\n>>> exceptions.try {\r\n>>>     false\r\n>>> }\r\n>>> exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\ncaught\r\n```\r\n\r\n```bash\r\n>>> exceptions.try {\r\n>>>     false\r\n>>> }\r\n>>> exceptions.catch\r\n>>> {\r\n>>>     echo caught\r\n>>> }\r\ncaught\r\n```\r\n### Function exceptions_deactivate\r\n\r\n\r\n```bash\r\n>>> set -o errtrace\r\n>>> trap 'echo $foo' ERR\r\n>>> exceptions.activate\r\n>>> trap -p ERR | cut --delimiter \"'\" --fields 2\r\n>>> exceptions.deactivate\r\n>>> trap -p ERR | cut --delimiter \"'\" --fields 2\r\nexceptions_error_handler\r\necho $foo\r\n```\r\n## Module logging\r\n\r\n\r\nThe available log levels are:\r\nerror critical warn info debug\r\n\r\nThe standard loglevel is critical\r\n```bash\r\n>>> logging.get_level\r\n>>> logging.get_commands_level\r\ncritical\r\ncritical\r\n```\r\n\r\n```bash\r\n>>> logging.error error-message\r\n>>> logging.critical critical-message\r\n>>> logging.warn warn-message\r\n>>> logging.info info-message\r\n>>> logging.debug debug-message\r\n+doc_test_contains\r\nerror-message\r\ncritical-message\r\n```\r\n\r\nIf the output of commands should be printed, the commands_level needs to be\r\ngreater than or equal to the log_level.\r\n```bash\r\n>>> logging.set_level critical\r\n>>> logging.set_commands_level debug\r\n>>> echo foo\r\n\r\n```\r\n\r\n```bash\r\n>>> logging.set_level info\r\n>>> logging.set_commands_level info\r\n>>> echo foo\r\nfoo\r\n```\r\n\r\nAnother logging prefix can be set by overriding \"logging_get_prefix\".\r\n```bash\r\n>>> logging_get_prefix() {\r\n>>>     local level=$1\r\n>>>     local path=\"${BASH_SOURCE[2]##./}\"\r\n>>>     path=$(basename \"$path\")\r\n>>>     echo \"[myprefix - ${level}:${path}]\"\r\n>>> }\r\n>>> logging.critical foo\r\n[myprefix - critical:doc_test.sh] foo\r\n```\r\n\r\n\"logging.plain\" can be used to print at any log level and without the\r\nprefix.\r\n```bash\r\n>>> logging.set_level critical\r\n>>> logging.set_commands_level debug\r\n>>> logging.plain foo\r\nfoo\r\n```\r\n\r\n\"logging.cat\" can be used to print files (e.g \"logging.cat < file.txt\")\r\nor heredocs. Like \"logging.plain\", it also prints at any log level and\r\nwithout the prefix.\r\n```bash\r\n>>> echo foo | logging.cat\r\nfoo\r\n```\r\n### Function logging_plain\r\n\r\n\r\n```bash\r\n>>> logging.set_level info\r\n>>> logging.set_commands_level debug\r\n>>> logging.debug \"not shown\"\r\n>>> echo \"not shown\"\r\n>>> logging.plain \"shown\"\r\nshown\r\n```\r\n### Function logging_set_file_descriptors\r\n\r\n\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging_set_file_descriptors \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\ntest_file:\r\n```\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging_set_file_descriptors \"$test_file\"\r\n>>> logging_set_file_descriptors \"\"\r\n>>> echo \"test_file:\" >\"$test_file\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\ntest_file:\r\n```\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging_set_file_descriptors \"$test_file\" --logging=tee\r\n>>> logging.plain foo\r\n>>> logging_set_file_descriptors \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\nfoo\r\ntest_file:\r\nfoo\r\n```\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging_set_file_descriptors \"$test_file\" --logging=off --commands=file\r\n>>> logging.plain not shown\r\n>>> echo foo\r\n>>> logging_set_file_descriptors \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\ntest_file:\r\nfoo\r\n```\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging_set_file_descriptors \"$test_file\" --logging=off\r\n>>> logging.plain not shown\r\n>>> echo foo\r\n>>> logging_set_file_descriptors \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\nfoo\r\ntest_file:\r\n```\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging_set_file_descriptors \"$test_file\" --commands=tee\r\n>>> logging.plain logging\r\n>>> echo echo\r\n>>> logging_set_file_descriptors \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\nlogging\r\necho\r\ntest_file:\r\necho\r\n```\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging_set_file_descriptors \"$test_file\" --commands=file\r\n>>> logging.plain logging\r\n>>> echo echo\r\n>>> logging_set_file_descriptors \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\nlogging\r\ntest_file:\r\necho\r\n```\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging_set_file_descriptors \"$test_file\" --logging=file --commands=file\r\n>>> logging.plain logging\r\n>>> echo echo\r\n>>> logging_set_file_descriptors \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\ntest_file:\r\nlogging\r\necho\r\n```\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging_set_file_descriptors \"$test_file\" --logging=file --commands=file\r\n>>> logging.plain logging\r\n>>> echo echo\r\n>>> logging_set_file_descriptors \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\ntest_file:\r\nlogging\r\necho\r\n```\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging_set_file_descriptors \"$test_file\" --logging=file --commands=tee\r\n>>> logging.plain logging\r\n>>> echo echo\r\n>>> logging_set_file_descriptors \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\necho\r\ntest_file:\r\nlogging\r\necho\r\n```\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging_set_file_descriptors \"$test_file\" --logging=file --commands=off\r\n>>> logging.plain logging\r\n>>> echo echo\r\n>>> logging_set_file_descriptors \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\ntest_file:\r\nlogging\r\n```\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging_set_file_descriptors \"$test_file\" --logging=tee --commands=tee\r\n>>> logging.plain logging\r\n>>> echo echo\r\n>>> logging_set_file_descriptors \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\nlogging\r\necho\r\ntest_file:\r\nlogging\r\necho\r\n```\r\n\r\nTest exit handler\r\n```bash\r\n>>> local test_file fifo\r\n>>> test_file=\"$(mktemp)\"\r\n>>> fifo=$(logging_set_file_descriptors \"$test_file\" --commands=tee; \\\r\n>>>    echo $logging_tee_fifo)\r\n>>> [ -p \"$fifo\" ] || echo fifo deleted\r\nfifo deleted\r\n```\r\n### Function logging_set_level\r\n\r\n\r\n```bash\r\n>>> logging.set_commands_level info\r\n>>> logging.set_level info\r\n>>> echo $logging_level\r\n>>> echo $logging_commands_level\r\n3\r\n3\r\n```\r\n### Function logging_set_log_file\r\n\r\n\r\n```bash\r\n>>> local test_file=\"$(mktemp )\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging.set_log_file \"$test_file\"\r\n>>> logging.plain logging\r\n>>> logging.set_log_file \"$test_file\"\r\n>>> echo echo\r\n>>> logging.set_log_file \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\nlogging\r\necho\r\ntest_file:\r\nlogging\r\necho\r\n```\r\n\r\n```bash\r\n>>> logging.set_commands_level debug\r\n>>> logging.set_level debug\r\n>>> local test_file=\"$(mktemp)\"\r\n>>> logging.plain \"test_file:\" >\"$test_file\"\r\n>>> logging.set_log_file \"$test_file\"\r\n>>> logging.plain 1\r\n>>> logging.set_log_file \"\"\r\n>>> logging.set_log_file \"$test_file\"\r\n>>> logging.plain 2\r\n>>> logging.set_log_file \"\"\r\n>>> logging.cat \"$test_file\"\r\n>>> rm \"$test_file\"\r\n1\r\n2\r\ntest_file:\r\n1\r\n2\r\n```\r\n## Module ui\r\n\r\n\r\nThis module provides variables for printing colorful and unicode glyphs.\r\nThe Terminal features are detected automatically but can also be\r\nenabled/disabled manually (see\r\n[ui.enable_color](#function-ui_enable_color) and\r\n[ui.enable_unicode_glyphs](#function-ui_enable_unicode_glyphs)).\r\n### Function ui_disable_color\r\n\r\n\r\nDisables color output explicitly.\r\n\r\n```bash\r\n>>> ui.enable_color\r\n>>> ui.disable_color\r\n>>> echo -E \"$ui_color_red\" red \"$ui_color_default\"\r\nred\r\n```\r\n### Function ui_disable_unicode_glyphs\r\n\r\n\r\nDisables unicode glyphs explicitly.\r\n\r\n```bash\r\n>>> ui.enable_unicode_glyphs\r\n>>> ui.disable_unicode_glyphs\r\n>>> echo -E \"$ui_powerline_ok\"\r\n+\r\n```\r\n### Function ui_enable_color\r\n\r\n\r\nEnables color output explicitly.\r\n\r\n```bash\r\n>>> ui.disable_color\r\n>>> ui.enable_color\r\n>>> echo -E $ui_color_red red $ui_color_default\r\n\u001B[0;31m red \u001B[0m\r\n```\r\n### Function ui_enable_unicode_glyphs\r\n\r\n\r\nEnables unicode glyphs explicitly.\r\n\r\n```bash\r\n>>> ui.disable_unicode_glyphs\r\n>>> ui.enable_unicode_glyphs\r\n>>> echo -E \"$ui_powerline_ok\"\r\n✔\r\n```\r\n## Module utils\r\n### Function utils_dependency_check\r\n\r\n\r\nThis function check if all given dependencies are present.\r\n\r\nExamples:\r\n\r\n```bash\r\n>>> utils_dependency_check mkdir ls; echo $?\r\n0\r\n```\r\n\r\n```bash\r\n>>> utils_dependency_check mkdir __not_existing__ 1>/dev/null; echo $?\r\n2\r\n```\r\n\r\n```bash\r\n>>> utils_dependency_check __not_existing__ 1>/dev/null; echo $?\r\n2\r\n```\r\n\r\n```bash\r\n>>> utils_dependency_check \"ls __not_existing__\"; echo $?\r\n__not_existing__\r\n2\r\n```\r\n### Function utils_dependency_check_pkgconfig\r\n\r\n\r\nThis function check if all given libraries can be found.\r\n\r\nExamples:\r\n\r\n```bash\r\n>>> utils_dependency_check_shared_library libc.so; echo $?\r\n0\r\n```\r\n\r\n```bash\r\n>>> utils_dependency_check_shared_library libc.so __not_existing__ 1>/dev/null; echo $?\r\n2\r\n```\r\n\r\n```bash\r\n>>> utils_dependency_check_shared_library __not_existing__ 1>/dev/null; echo $?\r\n2\r\n```\r\n### Function utils_dependency_check_shared_library\r\n\r\n\r\nThis function check if all given shared libraries can be found.\r\n\r\nExamples:\r\n\r\n```bash\r\n>>> utils_dependency_check_shared_library libc.so; echo $?\r\n0\r\n```\r\n\r\n```bash\r\n>>> utils_dependency_check_shared_library libc.so __not_existing__ 1>/dev/null; echo $?\r\n2\r\n```\r\n\r\n```bash\r\n>>> utils_dependency_check_shared_library __not_existing__ 1>/dev/null; echo $?\r\n2\r\n```\r\n### Function utils_find_block_device\r\n\r\n\r\n```bash\r\n>>> utils_find_block_device \"boot_partition\"\r\n/dev/sdb1\r\n```\r\n\r\n```bash\r\n>>> utils_find_block_device \"boot_partition\" /dev/sda\r\n/dev/sda2\r\n```\r\n\r\n```bash\r\n>>> utils_find_block_device \"discoverable by blkid\"\r\n/dev/sda2\r\n```\r\n\r\n```bash\r\n>>> utils_find_block_device \"_partition\"\r\n/dev/sdb1 /dev/sdb2\r\n```\r\n\r\n```bash\r\n>>> utils_find_block_device \"not matching anything\" || echo not found\r\nnot found\r\n```\r\n\r\n```bash\r\n>>> utils_find_block_device \"\" || echo not found\r\nnot found\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}