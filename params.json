{
  "name": "Rebash",
  "tagline": "ReBash - bash scripting library/framework",
  "body": "# ReBash - bash/shell library/framework\r\n## Features\r\n- modular import system\r\n- advanced logging (colors, control stdout/stderr, log levels, ...)\r\n- error handling (exceptions, try-catch)\r\n- doc testing inspired by python\r\n- documentation generation\r\n- argument parser\r\n\r\n## Usage\r\n```\r\n#!/usr/bin/env bash\r\nsource path/to/core.sh\r\ncore.import <modulename>\r\ncore.import <another modulename>\r\n# use modules ...\r\n```\r\n\r\n## Module Overview\r\n- [core](#module-core)\r\n- [logging](#module-logging)\r\n- [ui](#module-ui)\r\n- [exceptions](#module-exceptions)\r\n- [doc_test](#module-doc_test)\r\n- [documentation](#module-documentation)\r\n- [array](#module-array)\r\n- [arguments](#module-arguments)\r\n\r\n# Generated documentation\r\n## Module arguments\r\n## Module array\r\n## Module change_root\r\n### Function change_root\r\n\r\n\r\nThis function performs a linux change root if needed and provides all\r\nkernel api filesystems in target root by using a change root interface\r\nwith minimal needed rights.\r\n\r\nExamples:\r\n\r\n`change_root /new_root /usr/bin/env bash some arguments`\r\n### Function change_root_with_fake_fallback\r\n\r\n\r\nPerform the available change root program wich needs at least rights.\r\n\r\nExamples:\r\n\r\n`change_root_with_fake_fallback /new_root /usr/bin/env bash some arguments`\r\n### Function change_root_with_kernel_api\r\n\r\n\r\nPerforms a change root by mounting needed host locations in change root\r\nenvironment.\r\n\r\nExamples:\r\n\r\n`change_root_with_kernel_api /new_root /usr/bin/env bash some arguments`\r\n## Module core\r\n## Module dictionary\r\n### Function dictionary_get\r\n\r\n\r\nUsage:\r\nvariable=$(dictionary.get dictionary_name key)\r\n\r\nExamples:\r\n\r\n```bash\r\n>>> dictionary_get unset_map unset_value\r\n>>> dictionary_get unset_map unset_value; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_get unset_map unset_value; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> dictionary_set map foo 2\r\n>>> dictionary_set map bar 1\r\n>>> dictionary_get map foo\r\n>>> dictionary_get map bar\r\n2\r\n1\r\n```\r\n\r\n```bash\r\n>>> dictionary_set map foo \"a b c\"\r\n>>> dictionary_get map foo\r\na b c\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_set map foo 2\r\n>>> dictionary_get map foo\r\n2\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_set map foo \"a b c\"\r\n>>> dictionary_get map foo\r\na b c\r\n```\r\n### Function dictionary_get_keys\r\n\r\n\r\n```bash\r\n>>> dictionary_set map foo \"a b c\" bar 5\r\n>>> dictionary_get_keys map\r\nbar\r\nfoo\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_set map foo \"a b c\" bar 5\r\n>>> dictionary_get_keys map | sort -u\r\nbar\r\nfoo\r\n```\r\n### Function dictionary_set\r\n\r\n\r\nUsage:\r\ndictionary.set dictionary_name key value\r\n\r\nTests:\r\n\r\n```bash\r\n>>> dictionary_set map foo 2\r\n>>> echo ${dictionary__store_map[foo]}\r\n2\r\n```\r\n\r\n```bash\r\n>>> dictionary_set map foo \"a b c\" bar 5\r\n>>> echo ${dictionary__store_map[foo]}\r\n>>> echo ${dictionary__store_map[bar]}\r\na b c\r\n5\r\n```\r\n\r\n```bash\r\n>>> dictionary_set map foo \"a b c\" bar; echo $?\r\n1\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_set map foo 2\r\n>>> echo $dictionary__store_map_foo\r\n2\r\n```\r\n\r\n```bash\r\n>>> dictionary__bash_version_test=true\r\n>>> dictionary_set map foo \"a b c\"\r\n>>> echo $dictionary__store_map_foo\r\na b c\r\n```\r\n## Module doc_test\r\n\r\n\r\nThe doc_test module implements function and module level testing via \"doc\r\nstrings\".\r\n\r\nTests can be run by invoking `doc_test.sh file1 folder1 file2 ...`.\r\n\r\n#### Example output\r\n```bash\r\n[info:doc_test.sh:433] arguments_get_flag:[PASS]\r\n[info:doc_test.sh:433] arguments_get_keyword:[PASS]\r\n[info:doc_test.sh:433] arguments_get_parameter:[PASS]\r\n[info:doc_test.sh:433] arguments_set:[PASS]\r\n```\r\n\r\nA doc string can be defined for a function by defining a variable named\r\n`__doc__` at the function scope.\r\nOn the module level, the variable name should be `<module_name>__doc__`\r\n(e.g. `arguments__doc__` for the example above).\r\nNote: The doc string needs to be defined with single quotes.\r\n\r\nCode contained in a module level variable named\r\n`<module_name>__doc_test_setup__` will be run once before all the Tests of\r\na module are run. This is usefull for defining mockup functions/data\r\nthat can be used throughout all tests.\r\n\r\n#### Tests\r\n\r\nTests are delimited by blank lines:\r\n```bash\r\n>>> echo bar\r\nbar\r\n```\r\n\r\n```bash\r\n>>> echo $(( 1 + 2 ))\r\n3\r\n```\r\n\r\nBut can also occur right after another:\r\n```bash\r\n>>> echo foo\r\nfoo\r\n```\r\n\r\n```bash\r\n>>> echo bar\r\nbar\r\n```\r\n\r\nSingle quotes can be escaped like so:\r\n```bash\r\n>>> echo '$foos'\r\n$foos\r\n```\r\n\r\nOr so\r\n```bash\r\n>>> echo '$foos'\r\n$foos\r\n```\r\n\r\nSome text in between.\r\n\r\nMultiline output\r\n```bash\r\n>>> local i\r\n>>> for i in 1 2; do\r\n>>>     echo $i;\r\n>>> done\r\n1\r\n2\r\n```\r\n\r\nEllipsis support\r\n```bash\r\n>>> local i\r\n>>> for i in 1 2 3 4 5; do\r\n>>>     echo $i;\r\n>>> done\r\n+doc_test_ellipsis\r\n1\r\n2\r\n...\r\n```\r\n\r\nEllipsis are non greedy\r\n```bash\r\n>>> local i\r\n>>> for i in 1 2 3 4 5; do\r\n>>>     echo $i;\r\n>>> done\r\n+doc_test_ellipsis\r\n1\r\n...\r\n4\r\n5\r\n```\r\n\r\nEach testcase has its own scope:\r\n```bash\r\n>>> local testing=\"foo\"; echo $testing\r\nfoo\r\n```\r\n\r\n```bash\r\n>>> [ -z \"$testing\" ] && echo empty\r\nempty\r\n```\r\n\r\nSyntax error in testcode:\r\n```bash\r\n>>> f() {a}\r\n+doc_test_contains\r\n+doc_test_ellipsis\r\nsyntax error near unexpected token `{a}\r\n...\r\n```\r\n## Module documentation\r\n## Module exceptions\r\n\r\n\r\nNOTE: The try block is executed in a subshell, so no outer variables can be\r\nassigned.\r\n\r\n```bash\r\n>>> exceptions.activate\r\n>>> false\r\n+doc_test_ellipsis\r\nTraceback (most recent call first):\r\n...\r\n```\r\n\r\n```bash\r\n>>> exceptions_activate\r\n>>> exceptions.try {\r\n>>>     false\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\ncaught\r\n```\r\n\r\nExceptions in a subshell:\r\n```bash\r\n>>> exceptions_activate\r\n>>> ( false )\r\n+doc_test_ellipsis\r\nTraceback (most recent call first):\r\n...\r\nTraceback (most recent call first):\r\n...\r\n```\r\n\r\n```bash\r\n>>> exceptions_activate\r\n>>> exceptions.try {\r\n>>>     (false; echo \"this should not be printed\")\r\n>>>     echo \"this should not be printed\"\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\n+doc_test_ellipsis\r\ncaught\r\n```\r\n\r\nNested exceptions:\r\n```bash\r\n>>> exceptions_foo() {\r\n>>>     true\r\n>>>     exceptions.try {\r\n>>>         false\r\n>>>     }; exceptions.catch {\r\n>>>         echo caught inside foo\r\n>>>     }\r\n>>>     false # this is cought at top level\r\n>>>     echo this should never be printed\r\n>>> }\r\n>>>\r\n>>> exceptions.try {\r\n>>>     exceptions_foo\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\n>>>\r\ncaught inside foo\r\ncaught\r\n```\r\n\r\nExceptions are implicitely active inside try blocks:\r\n```bash\r\n>>> foo() {\r\n>>>     echo $1\r\n>>>     true\r\n>>>     exceptions.try {\r\n>>>         false\r\n>>>     }; exceptions.catch {\r\n>>>         echo caught inside foo\r\n>>>     }\r\n>>>     false # this is not caught\r\n>>>     echo this should never be printed\r\n>>> }\r\n>>>\r\n>>> foo \"EXCEPTIONS NOT ACTIVE:\"\r\n>>> exceptions_activate\r\n>>> foo \"EXCEPTIONS ACTIVE:\"\r\n+doc_test_ellipsis\r\nEXCEPTIONS NOT ACTIVE:\r\ncaught inside foo\r\nthis should never be printed\r\nEXCEPTIONS ACTIVE:\r\ncaught inside foo\r\nTraceback (most recent call first):\r\n...\r\n```\r\n\r\nExceptions inside conditionals:\r\n```bash\r\n>>> exceptions_activate\r\n>>> false && echo \"should not be printed\"\r\n>>> (false) && echo \"should not be printed\"\r\n>>> exceptions.try {\r\n>>>     (\r\n>>>     false\r\n>>>     echo \"should not be printed\"\r\n>>>     )\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\ncaught\r\n```\r\n\r\nReraise exception\r\n```bash\r\n>>> exceptions.try {\r\n>>>     false\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>>     echo \"$exceptions_last_traceback\"\r\n>>> }\r\n+doc_test_ellipsis\r\ncaught\r\nTraceback (most recent call first):\r\n...\r\n```\r\n\r\n```bash\r\n>>> exceptions.try {\r\n>>>     ! true\r\n>>> }; exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\n\r\n```\r\n\r\n```bash\r\n>>> exceptions.try\r\n>>>     false\r\n>>> exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\ncaught\r\n```\r\n\r\n```bash\r\n>>> exceptions.try\r\n>>>     false\r\n>>> exceptions.catch\r\n>>>     echo caught\r\ncaught\r\n```\r\n\r\n```bash\r\n>>> exceptions.try {\r\n>>>     false\r\n>>> }\r\n>>> exceptions.catch {\r\n>>>     echo caught\r\n>>> }\r\ncaught\r\n```\r\n\r\n```bash\r\n>>> exceptions.try {\r\n>>>     false\r\n>>> }\r\n>>> exceptions.catch\r\n>>> {\r\n>>>     echo caught\r\n>>> }\r\ncaught\r\n```\r\n## Module logging\r\n\r\n\r\nThe available log levels are:\r\nerror critical warn info debug\r\n\r\nThe standard loglevel is critical\r\n```bash\r\n>>> logging.get_level\r\n>>> logging.get_commands_level\r\ncritical\r\ncritical\r\n```\r\n\r\n```bash\r\n>>> logging.error error-message\r\n>>> logging.critical critical-message\r\n>>> logging.warn warn-message\r\n>>> logging.info info-message\r\n>>> logging.debug debug-message\r\n+doc_test_contains\r\nerror-message\r\ncritical-message\r\n```\r\n\r\nIf the output of commands should be printed, the commands_level needs to be\r\ngreater than or equal to the log_level.\r\n```bash\r\n>>> logging.set_level critical\r\n>>> logging.set_commands_level debug\r\n>>> echo foo\r\n\r\n```\r\n\r\n```bash\r\n>>> logging.set_level info\r\n>>> logging.set_commands_level info\r\n>>> echo foo\r\nfoo\r\n```\r\n\r\nAnother logging prefix can be set by overriding \"logging_get_prefix\".\r\n```bash\r\n>>> logging_get_prefix() {\r\n>>>     local level=$1\r\n>>>     local path=\"${BASH_SOURCE[2]##./}\"\r\n>>>     path=$(basename \"$path\")\r\n>>>     echo \"[myprefix - ${level}:${path}]\"\r\n>>> }\r\n>>> logging.critical foo\r\n[myprefix - critical:doc_test.sh] foo\r\n```\r\n\r\n\"logging.plain\" can be used to print at any log level and without the\r\nprefix.\r\n```bash\r\n>>> logging.set_level critical\r\n>>> logging.set_commands_level debug\r\n>>> logging.plain foo\r\nfoo\r\n```\r\n\r\n\"logging.cat\" can be used to print files (e.g \"logging.cat < file.txt\")\r\nor heredocs. Like \"logging.plain\", it also prints at any log level and\r\nwithout the prefix.\r\n```bash\r\n>>> echo foo | logging.cat\r\nfoo\r\n```\r\n## Module ui\r\n\r\n\r\nThis module provides variables for printing colorful and unicode glyphs.\r\nThe Terminal features are detected automatically but can also be\r\nenabled/disabled manually (see\r\n[ui.enable_color](#function-ui_enable_color) and\r\n[ui.enable_unicode_glyphs](#function-ui_enable_unicode_glyphs)).\r\n## Module utils\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}